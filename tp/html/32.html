<!DOCTYPE HTML>
<html lang="zh-CN">
	<head>
		<meta charset="GB2312">
		<title>闭包支持</title>
		<link rel="stylesheet" href="../images/css/book.css">
		<link rel="stylesheet" href="../images/prettify/prettify.css">
		<script type="text/javascript" src="../images/js/jquery-1.10.2.min.js"></script>
		<script type="text/javascript" src="../images/prettify/prettify.js"></script>
		<script type="text/javascript">
			$(function(){	
				$(window).resize(function(){
					$('.book-content').css('min-height', $(window).height() - 130);
				}).resize();
				
				var $code = $(".book-content pre");
				$code.each(function(){
					var $this = $(this), $code = $this.children("code"), lang = $code.attr("class");
					$this.addClass("prettyprint linenums");
					lang && $this.addClass("lang-" + lang);					
				});
				
				//调用高亮插件，高亮代码
				prettyPrint();
				
				//解决表格存在边距的问题
				$("table").attr({"cellspacing":"0", "cellpadding":"0"});
				
				//快捷键翻页
				$(document).keydown(function(event){
					if(event.keyCode == 37){ //上一页
						$(".book-title .prev span").click();
					} else if(event.keyCode == 39) {//下一页
						$(".book-title .next span").click();
					}
				});
				
			});
		</script>
	</head>
	<body>
		<div class="book-title">
			<h1>闭包支持</h1>
            <div class="page"><a title="上一页" class="prev" href="31.html"><span>上一页</span></a><a title="下一页" class="next" href="33.html"><span>下一页</span></a></div>
            <div class="description"></div>
		</div>
		<div class="book-content"><h2>闭包定义</h2>

<p>我们可以使用闭包的方式定义一些特殊需求的路由，而不需要执行控制器的操作方法了，例如：</p>

<pre><code>'URL_ROUTE_RULES'=&gt;array(
    'test'        =&gt; 
        function(){ 
            echo 'just test';
        },
    'hello/:name' =&gt; 
        function($name){ 
            echo 'Hello,'.$name;
        }
）
</code></pre>

<h2>参数传递</h2>

<p>闭包定义的参数传递在规则路由和正则路由的两种情况下有所区别。</p>

<h5>规则路由</h5>

<p>规则路由的参数传递比较简单：</p>

<pre><code>'hello/:name' =&gt; 
    function($name){ 
        echo 'Hello,'.$name;
    }
</code></pre>

<p>规则路由中定义的动态变量的名称 就是闭包函数中的参数名称，不分次序。
因此，如果我们访问的URL地址是：
<code>http://serverName/Home/hello/thinkphp</code></p>

<p>则浏览器输出的结果是：
<code>Hello,thinkphp</code></p>

<p>如果多个参数可以使用：</p>

<pre><code>'blog/:year/:month' =&gt; 
    function($year,$month){ 
        echo 'year='.$year.'&amp;month='.$month;
    }
</code></pre>

<h5>正则路由</h5>

<p>如果是正则路由的话，闭包函数中的参数就以正则中出现的参数次序来传递，例如：</p>

<pre><code>'/^new\/(\d{4})\/(\d{2})$/' =&gt; 
    function($year,$month){ 
        echo 'year='.$year.'&amp;month='.$month;
    }
</code></pre>

<p>如果我们访问：
<code>http://serverName/Home/new/2013/03</code>
浏览器输出结果是：
<code>year=2013&amp;month=03</code></p>

<h2>继续执行</h2>

<p>默认的情况下，使用闭包定义路由的话，一旦匹配到路由规则，执行完闭包方法之后，就会中止后续执行。如果希望闭包函数执行后，后续的程序继续执行，可以在闭包函数中使用布尔类型的返回值，例如：</p>

<pre><code>'hello/:name' =&gt; 
    function($name){ 
        echo 'Hello,'.$name.'&lt;br/&gt;';
        $_SERVER['PATH_INFO'] = 'blog/read/name/'.$name;
        return false;
    }
</code></pre>

<p>该路由定义中的闭包函数首先执行了一段输出代码，然后重新设置了<code>$_SERVER['PATH_INFO']</code>变量，交给后续的程序继续执行，因为返回值是false，所以会继续执行控制器和操作的检测，从而会执行Blog控制器的read操作方法。</p>

<p>假设blog控制器中的read操作方法代码如下：</p>

<pre><code>public function read($name){
    echo 'read,'.$name.'!&lt;br/&gt;';
}
</code></pre>

<p>如果我们访问的URL地址是：
<code>http://serverName/Home/hello/thinkphp</code></p>

<p>则浏览器输出的结果是：</p>

<pre><code>Hello,thinkphp
read,thinkphp!
</code></pre>
</div>
		<div class="book-footer">
			<div class="page"><a title="上一页" class="prev" href="31.html"><span>上一页</span></a><a title="下一页" class="next" href="33.html"><span>下一页</span></a></div>
		</div>
	</body>
</html>
