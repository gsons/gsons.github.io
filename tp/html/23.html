<!DOCTYPE HTML>
<html lang="zh-CN">
	<head>
		<meta charset="GB2312">
		<title>自动加载</title>
		<link rel="stylesheet" href="../images/css/book.css">
		<link rel="stylesheet" href="../images/prettify/prettify.css">
		<script type="text/javascript" src="../images/js/jquery-1.10.2.min.js"></script>
		<script type="text/javascript" src="../images/prettify/prettify.js"></script>
		<script type="text/javascript">
			$(function(){	
				$(window).resize(function(){
					$('.book-content').css('min-height', $(window).height() - 130);
				}).resize();
				
				var $code = $(".book-content pre");
				$code.each(function(){
					var $this = $(this), $code = $this.children("code"), lang = $code.attr("class");
					$this.addClass("prettyprint linenums");
					lang && $this.addClass("lang-" + lang);					
				});
				
				//调用高亮插件，高亮代码
				prettyPrint();
				
				//解决表格存在边距的问题
				$("table").attr({"cellspacing":"0", "cellpadding":"0"});
				
				//快捷键翻页
				$(document).keydown(function(event){
					if(event.keyCode == 37){ //上一页
						$(".book-title .prev span").click();
					} else if(event.keyCode == 39) {//下一页
						$(".book-title .next span").click();
					}
				});
				
			});
		</script>
	</head>
	<body>
		<div class="book-title">
			<h1>自动加载</h1>
            <div class="page"><a title="上一页" class="prev" href="22.html"><span>上一页</span></a><a title="下一页" class="next" href="24.html"><span>下一页</span></a></div>
            <div class="description"></div>
		</div>
		<div class="book-content"><p>在3.2中，基本上无需手动加载类库文件，你可以很方便的完成自动加载。</p>

<h2>命名空间自动加载</h2>

<p>系统可以通过类的命名空间自动定位到类库文件，例如：</p>

<p>我们定义了一个类 <code>Org\Util\Auth</code> 类：</p>

<pre><code>namespace Org\Util;
class Auth {
}
</code></pre>

<p>保存到 <code>ThinkPHP/Library/Org/Util/Auth.class.php</code>。</p>

<p>接下来，我们就可以直接实例化了。</p>

<pre><code>new \Org\Util\Auth();
</code></pre>

<p>在实例化<code>Org\Util\Auth</code>类的时候，系统会自动加载 <code>ThinkPHP/Library/Org/Util/Auth.class.php</code> 文件。</p>

<p>框架的Library目录下面的命名空间都可以自动识别和定位，例如：</p>

<pre><code>├─Library      框架类库目录
│  ├─Think     核心Think类库包目录
│  ├─Org       Org类库包目录
│  ├─ ...      更多类库目录
</code></pre>

<p>Library目录下面的子目录都是一个根命名空间，也就是说以Think、Org为根命名空间的类都可以自动加载：</p>

<pre><code>new Think\Cache\Driver\File();
new Org\Util\Auth();
new Org\Io\File();
</code></pre>

<p>都可以自动加载对应的类库文件。</p>

<blockquote>
  <p>你可以在Library目录下面任意增加新的目录，就会自动注册成为一个新的根命名空间。</p>
</blockquote>

<h2>注册新的命名空间</h2>

<p>除了Library目录下面的命名空间之外，我们还可以注册其他的根命名空间，例如：</p>

<pre><code>'AUTOLOAD_NAMESPACE' =&gt; array(
    'My'     =&gt; THINK_PATH.'My',
    'One'    =&gt; THINK_PATH.'One',
)
</code></pre>

<p>配置了上面的<code>AUTOLOAD_NAMESPACE</code>后，如果我们实例化下面的类库</p>

<pre><code>new My\Net\IpLocation();
new One\Util\Log();
</code></pre>

<p>会自动加载对应的类库文件</p>

<pre><code>ThinkPHP/My/Net/IpLocation.class.php
ThinkPHP/One/Util/Log.class.php
</code></pre>

<p>如果命名空间不在Library目录下面，并且没有定义对应的<code>AUTOLOAD_NAMESPACE</code>参数的话，则会当作模块的命名空间进行自动加载，例如：</p>

<pre><code>new Home\Model\UserModel();
new Home\Event\UserEvent();
</code></pre>

<p>由于ThinkPHP/Library目录下面不存在Home目录，也没在<code>AUTOLOAD_NAMESPACE</code>参数定义Home命名空间，所以就把Home当成模块命名空间来识别，所以会自动加载：</p>

<pre><code>Application/Home/Model/UserModel.class.php
Application/Home/Event/UserEvent.class.php
</code></pre>

<blockquote>
  <p>注意：命名空间的大小写需要和目录名的大小写对应，否则可能会自动加载失败。</p>
</blockquote>

<h2>类库映射</h2>

<p>遵循我们上面的命名空间定义规范的话，基本上可以完成类库的自动加载了，但是如果定义了较多的命名空间的话，效率会有所下降，所以，我们可以给常用的类库定义类库映射。命名类库映射相当于给类文件定义了一个别名，效率会比命名空间定位更高效，例如：</p>

<pre><code>Think\Think::addMap('Think\Log',THINK_PATH.'Think\Log.php');
Think\Think::addMap('Org\Util\Array',THINK_PATH.'Org\Util\Array.php');
</code></pre>

<p>也可以利用addMap方法批量导入类库映射定义，例如：</p>

<pre><code>$map = array('Think\Log'=&gt;THINK_PATH.'Think\Log.php','Org\Util\Array'=&gt;THINK_PATH.'Org\Util\Array.php');
Think\Think::addMap($map);
</code></pre>

<p>当然，比较方便的方式是我们可以在模块配置目录下面创建alias.php文件用于定义类库映射，该文件会自动加载，定义方式如下：</p>

<pre><code>return array(
    'Think\Log'        =&gt;    THINK_PATH.'Think\Log.php',
    'Org\Util\Array'   =&gt;    THINK_PATH.'Org\Util\Array.php'
);
</code></pre>

<h2>自动加载的优先级</h2>

<p>在实际的应用类库加载过程中，往往会涉及到自动加载的优先级问题，以<code>Test\MyClass</code>类为例，自动加载的优先顺序如下：</p>

<ol>
<li>判断是否有注册了Test\MyClass类库映射，如果有则自动加载类库映射定义的文件；  </li>
<li>判断是否存在Library/Test目录，有则以该目录为初始目录加载；  </li>
<li>判断是否有注册Test根命名空间，有则以注册的目录为初始目录加载；  </li>
<li>如果以上都不成立，则以Test为模块目录进行初始目录加载；  </li>
</ol>

<p>以上面获取到的初始目录加载命名空间对应路径的文件；</p>

<h2>手动加载第三方类库</h2>

<p>如果要加载第三方类库，包括<strong>不符合命名规范和后缀的类库，以及没有使用命名空间或者命名空间和路径不一致的类库</strong>，或者你就是想手动加载类库文件，我们都可以通过手动导入的方式加载。</p>

<p>我们可以使用import方法导入任何类库，用法如下：</p>

<pre><code>// 导入Org类库包 Library/Org/Util/Date.class.php类库
import("Org.Util.Date");
// 导入Home模块下面的 Application/Home/Util/UserUtil.class.php类库
import("Home.Util.UserUtil");
// 导入当前模块下面的类库 
import("@.Util.Array");
// 导入Vendor类库包 Library/Vendor/Zend/Server.class.php
import('Vendor.Zend.Server');
</code></pre>

<p>对于import方法，系统会自动识别导入类库文件的位置，ThinkPHP可以自动识别的类库包包括Think、Org、Com、Behavior和Vendor包，以及Library目录下面的子目录，如果你在Library目录下面创建了一个Test子目录，并且创建了一个UserTest.class.php类库，那么可以这样导入：</p>

<pre><code>import('Test.UserTest');
</code></pre>

<p>其他的就认为是应用类库导入。</p>

<p>注意，如果你的类库没有使用命名空间定义的话，实例化的时候需要加上根命名空间，例如：</p>

<pre><code>import('Test.UserTest');
$test = new \UserTest();
</code></pre>

<p>按照系统的规则，import方法是无法导入具有点号的类库文件的，因为点号会直接转化成斜线，例如我们定义了一个名称为User.Info.class.php 的文件的话，采用：</p>

<pre><code>import("Org.User.Info");
</code></pre>

<p>方式加载的话就会出现错误，导致加载的文件不是Org/User.Info.class.php 文件，而是Org/User/Info.class.php 文件，这种情况下，我们可以使用：</p>

<pre><code>import("Org.User#Info");
</code></pre>

<p>来导入。</p>

<p>大多数情况下，import方法都能够自动识别导入类库文件的位置，如果是特殊情况的导入，需要指定import方法的第二个参数作为起始导入路径。例如，要导入当前文件所在目录下面的
RBAC/AccessDecisionManager.class.php 文件，可以使用：</p>

<pre><code>import("RBAC.AccessDecisionManager",dirname(__FILE__));
</code></pre>

<p>如果你要导入的类库文件名的后缀不是class.php而是php，那么可以使用import方法的第三个参数指定后缀：</p>

<pre><code>import("RBAC.AccessDecisionManager",dirname(__FILE__),".php");
</code></pre>

<blockquote>
  <p>注意：在Unix或者Linux主机下面是区别大小写的，所以在使用import方法的时候要注意目录名和类库名称的大小写，否则会导入失败。</p>
</blockquote>

<p>如果你的第三方类库都放在Vendor目录下面，并且都以.php为类文件后缀，也没用采用命名空间的话，那么可以使用系统内置的Vendor函数简化导入。
例如，我们把 Zend 的 Filter\Dir.php 放到 Vendor 目录下面，这个时候 Dir 文件的路径就是 
Vendor\Zend\Filter\Dir.php，我们使用vendor 方法导入只需要使用：</p>

<pre><code>Vendor('Zend.Filter.Dir');
</code></pre>

<p>就可以导入Dir类库了。</p>

<p>Vendor方法也可以支持和import方法一样的基础路径和文件名后缀参数，例如：</p>

<pre><code>Vendor('Zend.Filter.Dir',dirname(__FILE__),'.class.php');
</code></pre>
</div>
		<div class="book-footer">
			<div class="page"><a title="上一页" class="prev" href="22.html"><span>上一页</span></a><a title="下一页" class="next" href="24.html"><span>下一页</span></a></div>
		</div>
	</body>
</html>
