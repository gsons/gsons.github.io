<!DOCTYPE HTML>
<html lang="zh-CN">
	<head>
		<meta charset="GB2312">
		<title>自动验证</title>
		<link rel="stylesheet" href="../images/css/book.css">
		<link rel="stylesheet" href="../images/prettify/prettify.css">
		<script type="text/javascript" src="../images/js/jquery-1.10.2.min.js"></script>
		<script type="text/javascript" src="../images/prettify/prettify.js"></script>
		<script type="text/javascript">
			$(function(){	
				$(window).resize(function(){
					$('.book-content').css('min-height', $(window).height() - 130);
				}).resize();
				
				var $code = $(".book-content pre");
				$code.each(function(){
					var $this = $(this), $code = $this.children("code"), lang = $code.attr("class");
					$this.addClass("prettyprint linenums");
					lang && $this.addClass("lang-" + lang);					
				});
				
				//调用高亮插件，高亮代码
				prettyPrint();
				
				//解决表格存在边距的问题
				$("table").attr({"cellspacing":"0", "cellpadding":"0"});
				
				//快捷键翻页
				$(document).keydown(function(event){
					if(event.keyCode == 37){ //上一页
						$(".book-title .prev span").click();
					} else if(event.keyCode == 39) {//下一页
						$(".book-title .next span").click();
					}
				});
				
			});
		</script>
	</head>
	<body>
		<div class="book-title">
			<h1>自动验证</h1>
            <div class="page"><a title="上一页" class="prev" href="91.html"><span>上一页</span></a><a title="下一页" class="next" href="93.html"><span>下一页</span></a></div>
            <div class="description"></div>
		</div>
		<div class="book-content"><p>自动验证是ThinkPHP模型层提供的一种数据验证方法，可以在使用create创建数据对象的时候自动进行数据验证。</p>

<h2>验证规则</h2>

<p>数据验证可以进行数据类型、业务规则、安全判断等方面的验证操作。</p>

<p>数据验证有两种方式：</p>

<ol>
<li>静态方式：在模型类里面通过$_validate属性定义验证规则。</li>
<li>动态方式：使用模型类的validate方法动态创建自动验证规则。</li>
</ol>

<p>无论是什么方式，验证规则的定义是统一的规则，定义格式为：</p>

<pre><code>array(
     array(验证字段1,验证规则,错误提示,[验证条件,附加规则,验证时间]),
     array(验证字段2,验证规则,错误提示,[验证条件,附加规则,验证时间]),
     ......
);
</code></pre>

<p>说明</p>

<h5>验证字段 （必须）</h5>

<p>需要验证的表单字段名称，这个字段不一定是数据库字段，也可以是表单的一些辅助字段，例如确认密码和验证码等等。有个别验证规则和字段无关的情况下，验证字段是可以随意设置的，例如expire有效期规则是和表单字段无关的。如果定义了字段映射的话，这里的验证字段名称应该是实际的数据表字段而不是表单字段。</p>

<h5>验证规则 （必须）</h5>

<p>要进行验证的规则，需要结合附加规则，如果在使用正则验证的附加规则情况下，系统还内置了一些常用正则验证的规则，可以直接作为验证规则使用，包括：require 字段必须、email 邮箱、url URL地址、currency 货币、number 数字。</p>

<h5>提示信息 （必须）</h5>

<p>用于验证失败后的提示信息定义</p>

<h5>验证条件 （可选）</h5>

<p>包含下面几种情况：</p>

<ul>
<li>self::EXISTS_VALIDATE 或者0 存在字段就验证（默认）  </li>
<li>self::MUST_VALIDATE 或者1 必须验证  </li>
<li>self::VALUE_VALIDATE或者2 值不为空的时候验证  </li>
</ul>

<h5>附加规则 （可选）</h5>

<p>配合验证规则使用，包括下面一些规则：
<table>
<thead>
<tr>
  <th>规则</th>
  <th>说明</th>
</tr>
</thead>
<tbody>
<tr>
  <td>regex</td>
  <td>正则验证，定义的验证规则是一个正则表达式（默认）</td>
</tr>
<tr>
  <td>function</td>
  <td>函数验证，定义的验证规则是一个函数名</td>
</tr>
<tr>
  <td>callback</td>
  <td>方法验证，定义的验证规则是当前模型类的一个方法</td>
</tr>
<tr>
  <td>confirm</td>
  <td>验证表单中的两个字段是否相同，定义的验证规则是一个字段名</td>
</tr>
<tr>
  <td>equal</td>
  <td>验证是否等于某个值，该值由前面的验证规则定义</td>
</tr>
<tr>
  <td>notequal</td>
  <td>验证是否不等于某个值，该值由前面的验证规则定义（3.1.2版本新增）</td>
</tr>
<tr>
  <td>in</td>
  <td>验证是否在某个范围内，定义的验证规则可以是一个数组或者逗号分割的字符串</td>
</tr>
<tr>
  <td>notin</td>
  <td>验证是否不在某个范围内，定义的验证规则可以是一个数组或者逗号分割的字符串（3.1.2版本新增）</td>
</tr>
<tr>
  <td>length</td>
  <td>验证长度，定义的验证规则可以是一个数字（表示固定长度）或者数字范围（例如3,12 表示长度从3到12的范围）</td>
</tr>
<tr>
  <td>between</td>
  <td>验证范围，定义的验证规则表示范围，可以使用字符串或者数组，例如1,31或者array(1,31)</td>
</tr>
<tr>
  <td>notbetween</td>
  <td>验证不在某个范围，定义的验证规则表示范围，可以使用字符串或者数组（3.1.2版本新增）</td>
</tr>
<tr>
  <td>expire</td>
  <td>验证是否在有效期，定义的验证规则表示时间范围，可以到时间，例如可以使用 2012-1-15,2013-1-15 表示当前提交有效期在2012-1-15到2013-1-15之间，也可以使用时间戳定义</td>
</tr>
<tr>
  <td>ip_allow</td>
  <td>验证IP是否允许，定义的验证规则表示允许的IP地址列表，用逗号分隔，例如201.12.2.5,201.12.2.6</td>
</tr>
<tr>
  <td>ip_deny</td>
  <td>验证IP是否禁止，定义的验证规则表示禁止的ip地址列表，用逗号分隔，例如201.12.2.5,201.12.2.6</td>
</tr>
<tr>
  <td>unique</td>
  <td>验证是否唯一，系统会根据字段目前的值查询数据库来判断是否存在相同的值，当表单数据中包含主键字段时unique不可用于判断主键字段本身</td>
</tr>
</tbody>
</table></p>

<h5>验证时间（可选）</h5>

<ul>
<li>self::MODEL_INSERT或者1新增数据时候验证  </li>
<li>self::MODEL_UPDATE或者2编辑数据时候验证  </li>
<li>self::MODEL_BOTH或者3全部情况下验证（默认）  </li>
</ul>

<p>这里的验证时间需要注意，并非只有这三种情况，你可以根据业务需要增加其他的验证时间。</p>

<h2>静态定义</h2>

<p>在模型类里面预先定义好该模型的自动验证规则，我们称为静态定义。</p>

<p>举例说明，我们在模型类里面定义了<code>$_validate</code>属性如下：</p>

<pre><code>namespace Home\Model;
use Think\Model;
class UserModel extends Model{
   protected $_validate = array(
     array('verify','require','验证码必须！'), //默认情况下用正则进行验证
     array('name','','帐号名称已经存在！',0,'unique',1), // 在新增的时候验证name字段是否唯一
     array('value',array(1,2,3),'值的范围不正确！',2,'in'), // 当值不为空的时候判断是否在一个范围内
     array('repassword','password','确认密码不正确',0,'confirm'), // 验证确认密码是否和密码一致
     array('password','checkPwd','密码格式不正确',0,'function'), // 自定义函数验证密码格式
   );
}
</code></pre>

<p>定义好验证规则后，就可以在使用create方法创建数据对象的时候自动调用：</p>

<pre><code>$User = D("User"); // 实例化User对象
if (!$User-&gt;create()){
     // 如果创建失败 表示验证没有通过 输出错误提示信息
     exit($User-&gt;getError());
}else{
     // 验证通过 可以进行其他数据操作
}
</code></pre>

<p>在进行自动验证的时候，系统会对定义好的验证规则进行依次验证。如果某一条验证规则没有通过，则会报错，getError方法返回的错误信息（字符串）就是对应字段的验证规则里面的错误提示信息。</p>

<blockquote>
  <p>静态定义方式因为必须定义模型类，所以只能用D函数实例化模型</p>
</blockquote>

<p>默认情况下，create方法是对表单提交的POST数据进行自动验证，如果你的数据来源不是表单post，仍然也可以进行自动验证，方法改进如下：</p>

<pre><code>$User = D("User"); // 实例化User对象
$data = getData(); // 通过getData方法获取数据源的（数组）数据
if (!$User-&gt;create($data)){
     // 对data数据进行验证
     exit($User-&gt;getError());
}else{
     // 验证通过 可以进行其他数据操作
}
</code></pre>

<p>一般情况下，create方法会自动判断当前是新增数据还是编辑数据（主要是通过表单的隐藏数据添加主键信息），你也可以明确指定当前创建的数据对象是新增还是编辑，例如：</p>

<pre><code>$User = D("User"); // 实例化User对象
if (!$User-&gt;create($_POST,1)){ // 指定新增数据
     // 如果创建失败 表示验证没有通过 输出错误提示信息
     exit($User-&gt;getError());
}else{
     // 验证通过 可以进行其他数据操作
}
</code></pre>

<p>create方法的第二个参数就用于指定自动验证规则中的验证时间，也就是说create方法的自动验证只会验证符合验证时间的验证规则。</p>

<p>我们在上面提到这里的验证时间并非只有这几种情况，你可以根据业务需要增加其他的验证时间，例如，你可以给登录操作专门指定验证时间为4。我们定义验证规则如下：</p>

<pre><code>namespace Home\Model;
use Think\Model;
class UserModel extends Model{
   protected $_validate = array(
     array('verify','require','验证码必须！'),  // 都有时间都验证
     array('name','checkName','帐号错误！',1,'function',4),  // 只在登录时候验证
     array('password','checkPwd','密码错误！',1,'function',4), // 只在登录时候验证
   );
}
</code></pre>

<p>那么，我们就可以在登录的时候使用</p>

<pre><code>$User = D("User"); // 实例化User对象
if (!$User-&gt;create($_POST,4)){ // 登录验证数据
     // 验证没有通过 输出错误提示信息
     exit($User-&gt;getError());
}else{
     // 验证通过 执行登录操作
}
</code></pre>

<h2>动态验证</h2>

<p>如果采用动态验证的方式，就比较灵活，可以根据不同的需要，在操作同一个模型的时候使用不同的验证规则，例如上面的静态验证方式可以改为：</p>

<pre><code>$rules = array(
     array('verify','require','验证码必须！'), //默认情况下用正则进行验证
     array('name','','帐号名称已经存在！',0,'unique',1), // 在新增的时候验证name字段是否唯一
     array('value',array(1,2,3),'值的范围不正确！',2,'in'), // 当值不为空的时候判断是否在一个范围内
     array('repassword','password','确认密码不正确',0,'confirm'), // 验证确认密码是否和密码一致
     array('password','checkPwd','密码格式不正确',0,'function'), // 自定义函数验证密码格式
);

$User = M("User"); // 实例化User对象
if (!$User-&gt;validate($rules)-&gt;create()){
     // 如果创建失败 表示验证没有通过 输出错误提示信息
     exit($User-&gt;getError());
}else{
     // 验证通过 可以进行其他数据操作
}
</code></pre>

<blockquote>
  <p>动态验证不依赖模型类的定义，所以通常用M函数实例化模型就可以</p>
</blockquote>

<h2>错误信息多语言支持</h2>

<p>如果你希望支持多语言的错误信息提示，那么可以在验证规则里面如下定义：</p>

<pre><code>protected $_validate = array(
     array('verify','require','{%VERIFY_CODE_MUST}'), 
     array('name','','{%ACCOUNT_EXISTS}',0,'unique',1), 
);
</code></pre>

<p>其中<code>VERIFY_CODE_MUST</code>和<code>ACCOUNT_EXISTS</code>是我们在语言包里面定义的多语言变量。</p>

<p>如果是采用动态验证方式，则比较简单，直接在定义验证规则的时候使用L方法即可，例如：</p>

<pre><code>$rules = array(
     array('verify','require',L('VERIFY_CODE_MUST')), 
     array('name','',L('ACCOUNT_EXISTS'),0,'unique',1), 
);
</code></pre>

<h2>批量验证</h2>

<p>系统支持数据的批量验证功能，只需要在模型类里面设置patchValidate属性为true（ 默认为false），</p>

<pre><code>protected $patchValidate = true;
</code></pre>

<p>设置批处理验证后，<code>getError()</code> 方法返回的错误信息是一个数组，返回格式是：</p>

<pre><code>array("字段名1"=&gt;"错误提示1","字段名2"=&gt;"错误提示2"... )
</code></pre>

<p>前端可以根据需要需要自行处理，例如转换成json格式返回：</p>

<pre><code>$User = D("User"); // 实例化User对象
if (!$User-&gt;create()){
     // 如果创建失败 表示验证没有通过 输出错误提示信息
     $this-&gt;ajaxReturn($User-&gt;getError());
}else{
     // 验证通过 可以进行其他数据操作
}
</code></pre>
</div>
		<div class="book-footer">
			<div class="page"><a title="上一页" class="prev" href="91.html"><span>上一页</span></a><a title="下一页" class="next" href="93.html"><span>下一页</span></a></div>
		</div>
	</body>
</html>
