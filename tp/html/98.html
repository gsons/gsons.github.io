<!DOCTYPE HTML>
<html lang="zh-CN">
	<head>
		<meta charset="GB2312">
		<title>关联模型</title>
		<link rel="stylesheet" href="../images/css/book.css">
		<link rel="stylesheet" href="../images/prettify/prettify.css">
		<script type="text/javascript" src="../images/js/jquery-1.10.2.min.js"></script>
		<script type="text/javascript" src="../images/prettify/prettify.js"></script>
		<script type="text/javascript">
			$(function(){	
				$(window).resize(function(){
					$('.book-content').css('min-height', $(window).height() - 130);
				}).resize();
				
				var $code = $(".book-content pre");
				$code.each(function(){
					var $this = $(this), $code = $this.children("code"), lang = $code.attr("class");
					$this.addClass("prettyprint linenums");
					lang && $this.addClass("lang-" + lang);					
				});
				
				//调用高亮插件，高亮代码
				prettyPrint();
				
				//解决表格存在边距的问题
				$("table").attr({"cellspacing":"0", "cellpadding":"0"});
				
				//快捷键翻页
				$(document).keydown(function(event){
					if(event.keyCode == 37){ //上一页
						$(".book-title .prev span").click();
					} else if(event.keyCode == 39) {//下一页
						$(".book-title .next span").click();
					}
				});
				
			});
		</script>
	</head>
	<body>
		<div class="book-title">
			<h1>关联模型</h1>
            <div class="page"><a title="上一页" class="prev" href="97.html"><span>上一页</span></a><a title="下一页" class="next" href="99.html"><span>下一页</span></a></div>
            <div class="description"></div>
		</div>
		<div class="book-content"><h2>关联关系</h2>

<p>通常我们所说的关联关系包括下面三种：</p>

<pre><code>一对一关联 ：ONE_TO_ONE，包括HAS_ONE 和 BELONGS_TO 
一对多关联 ：ONE_TO_MANY，包括HAS_MANY 和 BELONGS_TO
多对多关联 ：MANY_TO_MANY
</code></pre>

<p>关联关系必然有一个参照表，例如：</p>

<ul>
<li>有一个员工档案管理系统项目，这个项目要包括下面的一些数据表：基本信息表、员工档案表、部门表、项目组表、银行卡表（用来记录员工的银行卡资料）。</li>
<li>这些数据表之间存在一定的关联关系，我们以员工基本信息表为参照来分析和其他表之间的关联：</li>
<li>每个员工必然有对应的员工档案资料，所以属于HAS_ONE关联；</li>
<li>每个员工必须属于某个部门，所以属于BELONGS_TO关联；</li>
<li>每个员工可以有多个银行卡，但是每张银行卡只可能属于一个员工，因此属于HAS_MANY关联；</li>
<li>每个员工可以同时在多个项目组，每个项目组同时有多个员工，因此属于MANY_TO_MANY关联；</li>
<li>分析清楚数据表之前的关联关系后，我们才可以进行关联定义和关联操作。  </li>
</ul>

<h2>关联定义</h2>

<p>ThinkPHP可以很轻松的完成数据表的关联CURD操作，目前支持的关联关系包括下面四种：</p>

<p><strong>HAS_ONE</strong>、<strong>BELONGS_TO</strong>、<strong>HAS_MANY</strong>和<strong>MANY_TO_MANY</strong>。</p>

<p>一个模型根据业务模型的复杂程度可以同时定义多个关联，不受限制，所有的关联定义都统一在模型类的 $_link 成员变量里面定义，并且可以支持动态定义。要支持关联操作，模型类必须继承<code>Think\Model\RelationModel</code>类，关联定义的格式是：</p>

<pre><code>namespace Home\Model;
use Think\Model\RelationModel;
class UserModel extends RelationModel{
    protected $_link = array(
         '关联1'  =&gt;  array(
             '关联属性1' =&gt; '定义',
             '关联属性N' =&gt; '定义',
         ),
         '关联2'  =&gt;  array(
             '关联属性1' =&gt; '定义',
             '关联属性N' =&gt; '定义',
         ),
         '关联3'  =&gt;  HAS_ONE, // 快捷定义
         ...
    );
}
</code></pre>

<p>下面我们首先来分析下各个关联方式的定义：</p>

<h3>HAS_ONE</h3>

<p>HAS_ONE关联表示当前模型拥有一个子对象，例如，每个员工都有一个人事档案。我们可以建立一个用户模型UserModel，并且添加如下关联定义：</p>

<pre><code>namespace Home\Model;
use Think\Model\RelationModel;
class UserModel extends RelationModel{
     protected $_link = array(
        'Profile'=&gt; self::HAS_ONE,
     );
}
</code></pre>

<p>上面是最简单的方式，表示其遵循了系统内置的数据库规范，完整的定义方式是：</p>

<pre><code>namespace Home\Model;
use Think\Model\RelationModel;
class UserModel extends RelationModel{
    protected $_link = array(
        'Profile'=&gt;array(
            'mapping_type'      =&gt; self::HAS_ONE,
            'class_name'        =&gt; 'Profile',
            // 定义更多的关联属性
            ……
            ),
        );
}
</code></pre>

<p>关联HAS_ONE支持的关联属性有：
mapping_type :关联类型</p>

<p>这个在HAS_ONE 关联里面必须使用HAS_ONE 常量定义。</p>

<p>class_name ：要关联的模型类名</p>

<p>例如，class_name 定义为Profile的话则表示和另外的Profile模型类关联，这个Profile模型类是无需定义的，系统会自动定位到相关的数据表进行关联。</p>

<p>mapping_name  ：关联的映射名称，用于获取数据用</p>

<p>该名称不要和当前模型的字段有重复，否则会导致关联数据获取的冲突。如果mapping_name没有定义的话，会取class_name的定义作为mapping_name。如果class_name也没有定义，则以数组的索引作为mapping_name。</p>

<p>foreign_key ： 关联的外键名称</p>

<p>外键的默认规则是当前数据对象名称_id，例如：
UserModel对应的可能是表think_user （注意：think只是一个表前缀，可以随意配置）
 那么think_user表的外键默认为 user_id，如果不是，就必须在定义关联的时候显式定义 foreign_key 。</p>

<p>condition ： 关联条件</p>

<p>关联查询的时候会自动带上外键的值，如果有额外的查询条件，可以通过定义关联的condition属性。</p>

<p>mapping_fields ： 关联要查询的字段</p>

<p>默认情况下，关联查询的关联数据是关联表的全部字段，如果只是需要查询个别字段，可以定义关联的mapping_fields属性。</p>

<p>as_fields ：直接把关联的字段值映射成数据对象中的某个字段</p>

<p>这个特性是ONE_TO_ONE 关联特有的，可以直接把关联数据映射到数据对象中，而不是作为一个关联数据。当关联数据的字段名和当前数据对象的字段名称有冲突时，还可以使用映射定义。</p>

<h3>BELONGS_TO</h3>

<p>Belongs_to 关联表示当前模型从属于另外一个父对象，例如每个用户都属于一个部门。我们可以做如下关联定义。</p>

<pre><code>'Dept' =&gt; self::BELONGS_TO
</code></pre>

<p>完整方式定义为：</p>

<pre><code>'Dept' =&gt; array(
    'mapping_type'  =&gt; self::BELONGS_TO,
    'class_name'    =&gt; 'Dept',
    'foreign_key'   =&gt; 'userId',
    'mapping_name'  =&gt; 'dept',
    // 定义更多的关联属性
    ……
),
</code></pre>

<p>关联BELONGS_TO定义支持的关联属性有：
<table>
<thead>
<tr>
  <th>属性</th>
  <th>描述</th>
</tr>
</thead>
<tbody>
<tr>
  <td>class_name</td>
  <td>要关联的模型类名</td>
</tr>
<tr>
  <td>mapping_name</td>
  <td>关联的映射名称，用于获取数据用 该名称不要和当前模型的字段有重复，否则会导致关联数据获取的冲突。</td>
</tr>
<tr>
  <td>foreign_key</td>
  <td>关联的外键名称</td>
</tr>
<tr>
  <td>mapping_fields</td>
  <td>关联要查询的字段</td>
</tr>
<tr>
  <td>condition</td>
  <td>关联条件</td>
</tr>
<tr>
  <td>parent_key</td>
  <td>自引用关联的关联字段 默认为parent_id 自引用关联是一种比较特殊的关联，也就是关联表就是当前表。</td>
</tr>
<tr>
  <td>as_fields</td>
  <td>直接把关联的字段值映射成数据对象中的某个字段</td>
</tr>
</tbody>
</table></p>

<h3>HAS_MANY</h3>

<p>HAS_MANY 关联表示当前模型拥有多个子对象，例如每个用户有多篇文章，我们可以这样来定义：</p>

<pre><code>'Article' =&gt; self::HAS_MANY
</code></pre>

<p>完整定义方式为：</p>

<pre><code>'Article' =&gt; array(
    'mapping_type'  =&gt; self::HAS_MANY,
    'class_name'    =&gt; 'Article',
    'foreign_key'   =&gt; 'userId',
    'mapping_name'  =&gt; 'articles',
    'mapping_order' =&gt; 'create_time desc',
    // 定义更多的关联属性
    ……
),
</code></pre>

<p>关联HAS_MANY定义支持的关联属性有：
<table>
<thead>
<tr>
  <th>属性</th>
  <th>描述</th>
</tr>
</thead>
<tbody>
<tr>
  <td>class_name</td>
  <td>要关联的模型类名</td>
</tr>
<tr>
  <td>mapping_name</td>
  <td>关联的映射名称，用于获取数据用 该名称不要和当前模型的字段有重复，否则会导致关联数据获取的冲突。</td>
</tr>
<tr>
  <td>foreign_key</td>
  <td>关联的外键名称</td>
</tr>
<tr>
  <td>parent_key</td>
  <td>自引用关联的关联字段 默认为parent_id</td>
</tr>
<tr>
  <td>condition</td>
  <td>关联条件  关联查询的时候会自动带上外键的值，如果有额外的查询条件，可以通过定义关联的condition属性。</td>
</tr>
<tr>
  <td>mapping_fields</td>
  <td>关联要查询的字段 默认情况下，关联查询的关联数据是关联表的全部字段，如果只是需要查询个别字段，可以定义关联的mapping_fields属性。</td>
</tr>
<tr>
  <td>mapping_limit</td>
  <td>关联要返回的记录数目</td>
</tr>
<tr>
  <td>mapping_order</td>
  <td>关联查询的排序</td>
</tr>
</tbody>
</table></p>

<p>外键的默认规则是当前数据对象名称_id，例如：UserModel对应的可能是表think_user （注意：think只是一个表前缀，可以随意配置）
那么think_user表的外键默认为 user_id，如果不是，就必须在定义关联的时候定义 foreign_key 。</p>

<h3>MANY_TO_MANY</h3>

<p>MANY_TO_MANY 关联表示当前模型可以属于多个对象，而父对象则可能包含有多个子对象，通常两者之间需要一个中间表类约束和关联。例如每个用户可以属于多个组，每个组可以有多个用户：</p>

<pre><code>'Group' =&gt; self::MANY_TO_MANY
</code></pre>

<p>完整定义方式为：</p>

<pre><code>'Group' =&gt; array(
    'mapping_type'      =&gt;  self::MANY_TO_MANY,
    'class_name'        =&gt;  'Group',
    'mapping_name'      =&gt;  'groups',
    'foreign_key'       =&gt;  'userId',
    'relation_foreign_key'  =&gt;  'groupId',
    'relation_table'    =&gt;  'think_group_user' //此处应显式定义中间表名称，且不能使用C函数读取表前缀
    )
</code></pre>

<p>MANY_TO_MANY支持的关联属性定义有：</p>

<table>
<thead>
<tr>
  <th>属性</th>
  <th>描述</th>
</tr>
</thead>
<tbody>
<tr>
  <td>class_name</td>
  <td>要关联的模型类名</td>
</tr>
<tr>
  <td>mapping_name</td>
  <td>关联的映射名称，用于获取数据用 该名称不要和当前模型的字段有重复，否则会导致关联数据获取的冲突。</td>
</tr>
<tr>
  <td>foreign_key</td>
  <td>关联的外键名称 外键的默认规则是当前数据对象名称_id</td>
</tr>
<tr>
  <td>relation_foreign_key</td>
  <td>关联表的外键名称 默认的关联表的外键名称是表名_id</td>
</tr>
<tr>
  <td>mapping_limit</td>
  <td>关联要返回的记录数目</td>
</tr>
<tr>
  <td>mapping_order</td>
  <td>关联查询的排序</td>
</tr>
<tr>
  <td>relation_table</td>
  <td>多对多的中间关联表名称</td>
</tr>
</tbody>
</table>

<p>多对多的中间表默认表规则是：<strong>数据表前缀&#95;关联操作的主表名&#95;关联表名</strong></p>

<p>如果think_user 和 think_group 存在一个对应的中间表，默认的表名应该是
 如果是由group来操作关联表，中间表应该是 think_group_user，如果是从user表来操作，那么应该是think_user_group，也就是说，多对多关联的设置，必须有一个Model类里面需要显式定义中间表，否则双向操作会出错。
 中间表无需另外的id主键（但是这并不影响中间表的操作），通常只是由 user_id 和 group_id 构成。
 默认会通过当前模型的getRelationTableName方法来自动获取，如果当前模型是User，关联模型是Group，那么关联表的名称也就是使用 user_group这样的格式，如果不是默认规则，需要指定relation_table属性。</p>

<p><strong>3.2.2版本</strong>开始，relation_table定义支持简化写法，例如：</p>

<pre><code>'relation_table'=&gt;'__USER_GROUP__'
</code></pre>

<h2>关联查询</h2>

<p>由于性能问题，新版取消了自动关联查询机制，而统一使用relation方法进行关联操作，relation方法不但可以启用关联还可以控制局部关联操作，实现了关联操作一切尽在掌握之中。</p>

<pre><code>$User = D("User");
$user = $User-&gt;relation(true)-&gt;find(1);
</code></pre>

<p>输出$user结果可能是类似于下面的数据：</p>

<pre><code>array(
    'id'        =&gt; 1,
    'account'   =&gt; 'ThinkPHP',
    'password'  =&gt; '123456',
    'Profile'   =&gt; array(
        'email'     =&gt; 'liu21st@gmail.com',
        'nickname'  =&gt; '流年',
        ),
    )
</code></pre>

<p>我们可以看到，用户的关联数据已经被映射到数据对象的属性里面了。其中Profile就是关联定义的mapping_name属性。</p>

<p>如果我们按照下面的方式定义了as_fields属性的话，</p>

<pre><code>protected $_link = array(
    'Profile'=&gt;array(
        'mapping_type'  =&gt; self::HAS_ONE,
        'class_name'    =&gt; 'Profile',
        'foreign_key'   =&gt; 'userId',
        'as_fields' =&gt; 'email,nickname',
        ),
    );
</code></pre>

<p>查询的结果就变成了下面的结果</p>

<pre><code>array(
    'id'        =&gt; 1,
    'account'   =&gt; 'ThinkPHP',
    'password'  =&gt; 'name',
    'email'     =&gt; 'liu21st@gmail.com',
    'nickname'  =&gt; '流年',
    )
</code></pre>

<p>email和nickname两个字段已经作为user数据对象的字段来显示了。</p>

<p>如果关联数据的字段名和当前数据对象的字段有冲突的话，怎么解决呢？</p>

<p>我们可以用下面的方式来变化下定义：</p>

<pre><code>'as_fields' =&gt; 'email,nickname:username',
</code></pre>

<p>表示关联表的nickname字段映射成当前数据对象的username字段。</p>

<p>默认会把所有定义的关联数据都查询出来，有时候我们并不希望这样，就可以给relation方法传入参数来控制要关联查询的。</p>

<pre><code>$User = D("User");
$user = $User-&gt;relation('Profile')-&gt;find(1);
</code></pre>

<p>关联查询一样可以支持select方法，如果要查询多个数据，并同时获取相应的关联数据，可以改成：</p>

<pre><code>$User = D("User");
$list = $User-&gt;relation(true)-&gt;Select();
</code></pre>

<p>如果希望在完成的查询基础之上 再进行关联数据的查询，可以使用</p>

<pre><code>$User = D("User");
$user = $User-&gt;find(1);
// 表示对当前查询的数据对象进行关联数据获取
$profile = $User-&gt;relationGet("Profile");
</code></pre>

<p>事实上，除了当前的参考模型User外，其他的关联模型是不需要创建的。</p>

<h2>关联操作</h2>

<p>除了关联查询外，系统也支持关联数据的自动写入、更新和删除</p>

<h3>关联写入</h3>

<pre><code>$User = D("User");
$data = array();
$data["account"]    = "ThinkPHP";
$data["password"]   = "123456";
$data["Profile"]    = array(
  'email'    =&gt;'liu21st@gmail.com',
  'nickname'    =&gt;'流年',
);
$result = $User-&gt;relation(true)-&gt;add($data);
</code></pre>

<p>这样就会自动写入关联的Profile数据。</p>

<p>同样，可以使用参数来控制要关联写入的数据：</p>

<pre><code>$result = $User-&gt;relation("Profile")-&gt;add($data);
</code></pre>

<h3>关联更新</h3>

<p>数据的关联更新和关联写入类似</p>

<pre><code>$User = D("User");
$data["account"]    = "ThinkPHP";
$data["password"]   = "123456";
$data["Profile"]    = array(
     'email'    =&gt;'liu21st@gmail.com',
     'nickname'    =&gt;'流年',
);
$result = $User-&gt; relation(true)-&gt;where('id=3')-&gt;save($data);
</code></pre>

<p>Relation(true)会关联保存User模型定义的所有关联数据，如果只需要关联保存部分数据，可以使用：</p>

<pre><code>$result = $User-&gt;relation("Profile")-&gt;save($data);
</code></pre>

<p>这样就只会同时更新关联的Profile数据。</p>

<p>关联保存的规则：</p>

<p><strong>HAS_ONE</strong>： 关联数据的更新直接赋值</p>

<p><strong>HAS_MANY</strong>： 的关联数据如果传入主键的值 则表示更新 否则就表示新增</p>

<p><strong>MANY_TO_MANY</strong>： 的数据更新是删除之前的数据后重新写入</p>

<h3>关联删除</h3>

<pre><code>//删除用户ID为3的记录的同时删除关联数据
$result = $User-&gt;relation(true)-&gt;delete("3");
// 如果只需要关联删除部分数据，可以使用
$result = $User-&gt;relation("Profile")-&gt;delete("3");
</code></pre>
</div>
		<div class="book-footer">
			<div class="page"><a title="上一页" class="prev" href="97.html"><span>上一页</span></a><a title="下一页" class="next" href="99.html"><span>下一页</span></a></div>
		</div>
	</body>
</html>
